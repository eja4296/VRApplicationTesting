<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <title>VR Graph/Network Data Visualization Application Prototype</title>
    
    <style>
        
    </style>
    
    <!-- import aFrame Library -->
    <script src="https://aframe.io/releases/0.5.0/aframe.min.js"></script>
    <script src="js/aframe-line-component.min.js"></script>
    <script src="js/keys.js"></script>

    
        <script type="x-shader/x-vertex" id="vertexshader">
			attribute float size;
			attribute vec4 ca;
			varying vec4 vColor;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = size * ( 150.0 / -mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec4 vColor;
			void main() {
				vec4 outColor = texture2D( texture, gl_PointCoord );
				if ( outColor.a < 0.5 ) discard;
				gl_FragColor = outColor * vec4( color * vColor.xyz, 1.0 );
				float depth = gl_FragCoord.z / gl_FragCoord.w;
				const vec3 fogColor = vec3( 0.0 );
				float fogFactor = smoothstep( 200.0, 600.0, depth );
				gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );
			}
		</script>

    
    
    <!-- Main Script -->
    <script>

        // IIFE
        (function(){
            'use strict';
            
            // variables
            var aScene;
            var camera;
            var cursor;
            var entered;
            var popUpInfo;
            var popUpInfoPlane;
            var popUpImage;
            var popUpPosition;
            
            var allNodes;
            var allEdges;
            var nodePositions;
            var neighborList;
            var forceOnNode;
            
            // Force Constants
            const springConstant = 8;
            const coulombConstant = 8.99 * Math.pow(10,9);
            const nodeCharge = 0.00005;
            const springEquilibrium = 1;

            
            // Extra variables; may not need later
            var rotations = 0;
            var continueCalculations = [];
            var debugLine;
            var layoutSpeed = 1;
            var prevPosition = [];
            
            var displacement = 0;
            var maxForce = 0;
            var minForce = 0;
            
            var meanForce = 0;
            var meanForceIndexTracker = 1;
            var percentForce = 0;
            var calculating = true;
            
            var start;
            var elapsed;
            var steps = 0;
            var stepTime = 0;
            var averageStepTime = 0;
            
            var startPositions = [];
            var edgeTimer = 0;
            
            var edgeAnimation = false;
            
            var keepCalculating = [];
            
            
            var cameraPosition;
            
            var mostConnected = 0;
            
            var myKeys = {};
            
            var cameraSpeed = new THREE.Vector3(0,0,0);
            var cameraMaxSpeed = 1;
            var menu;
            
            var geometry;
            var material;
            var colors;
            var positions;
            var group;
            var scene;
            var renderer;
            var mesh;
            var nodeMesh;
            var camera3;
            var lineVertices;
            var aspect;
            var nodeGeometry;
            var nodeColors;
            
            
            myKeys.KEYBOARD = Object.freeze({
                "KEY_e": 69,
                "KEY_q": 81,
                "KEY_LEFT": 37, 
                "KEY_UP": 38, 
                "KEY_RIGHT": 39, 
                "KEY_DOWN": 40,
                "KEY_SPACE": 32,
                "KEY_SHIFT": 16,
                "KEY_w": 87,
                "KEY_a": 65,
                "KEY_s": 83,
                "KEY_d": 68,
                "KEY_r": 82,
                "KEY_c": 67,
                "KEY_x": 88
            })
            
            myKeys.keydown = [];

            // Starter function
            function init(){
                // get aframe scene element
                aScene = document.querySelector("#scene");
                menu = document.querySelector('#menu');
                group = new THREE.Group();
                scene = document.querySelector('#scene').object3D;
                scene.add( group );
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(renderer.domElement);
                aspect = window.innerWidth / window.innerHeight;
                camera3 = new THREE.PerspectiveCamera(75, aspect, 1, 1000);
                
                
                // Node and Edge information holders
                allNodes = [];
                allEdges = [];
                nodePositions = [];
                neighborList = [];
                forceOnNode = [];
                
                // test image
                popUpInfo = document.createElement('a-text');
                popUpInfoPlane = document.createElement('a-plane');
                popUpImage = document.createElement('a-image');
                popUpImage.setAttribute('opacity', 0.0);
                popUpInfoPlane.setAttribute('opacity', 0.0);
                popUpInfo.setAttribute('opacity', 0.0);
                aScene.appendChild(popUpInfo);
                aScene.appendChild(popUpInfoPlane);
                aScene.appendChild(popUpImage);
                camera = document.querySelector('#camera');
                entered = false;
                cursor = document.querySelector("#cursor");
                popUpPosition = {
                  x: 0,
                  y: 0,
                  z: 0
                };

                cameraPosition = new THREE.Vector3(camera.getAttribute('position').x, camera.getAttribute('position').y, camera.getAttribute('position').z);
                
                
                // For Event Listeners
                window.addEventListener('keydown', checkKeyDown);  
                window.addEventListener('keyup', checkKeyUp);  
                //window.addEventListener('wheel', zoom);  
                
                // Cursor Listeners, Click, Enter
                AFRAME.registerComponent('cursor-listener', {
                  
                  init: function () {
                    var COLORS = ['red', 'green', 'blue'];
                    // Cursor Click
                    this.el.addEventListener('click', function (event) {
                        
                        
                      console.log('I was clicked at: ', event.detail.intersection.point);
                      
                      popUpImage.setAttribute('src', 'media/gsk-logo.jpg');
                      popUpImage.setAttribute('height', 0.25);
                      popUpImage.setAttribute('width', 0.5);
                      popUpImage.setAttribute('opacity', 1.0);
                      popUpImage.setAttribute('position', '' + (cameraPosition.x - 2) + ' ' + (cameraPosition.y) + ' ' + (cameraPosition.z - 3.199) + '');
                        
                      popUpInfoPlane.setAttribute('height', 0.25);
                      popUpInfoPlane.setAttribute('width', 1.5);
                      popUpInfoPlane.setAttribute('opacity', 1.0);
                      popUpInfoPlane.setAttribute('position', '' + (cameraPosition.x - 1.5) + ' ' + (cameraPosition.y) + ' ' + (cameraPosition.z - 3.2) + '');
                        
                      popUpInfo.setAttribute('value', this.getAttribute('label'));
                      popUpInfo.setAttribute('color', 'black');
                      popUpInfo.setAttribute('height', '1');
                      popUpInfo.setAttribute('width', '2');
                      popUpInfo.setAttribute('opacity', 1.0);
                      popUpInfo.setAttribute('position', '' + (cameraPosition.x - 1.5) + ' ' + (cameraPosition.y) + ' ' + (cameraPosition.z - 3.19) + '');
                        
                      //menu.object3D.lookAt(cameraPosition);
                      /*
                      var teleport = document.createElement('a-animation');
                      teleport.setAttribute('easing', 'ease-out');
                      teleport.setAttribute('attribute', 'position');
                      teleport.setAttribute('from', '' + camera.getAttribute('position').x + ' ' + camera.getAttribute('position').y + ' ' + camera.getAttribute('position').z + '');
                      teleport.setAttribute('to', '' + (event.detail.intersection.point.x) + ' ' + (event.detail.intersection.point.y + 0.5) + ' ' + (event.detail.intersection.point.z + 3) + '');
                      teleport.setAttribute('dur', '5000');
                      camera.appendChild(teleport);
                      cameraPosition.x = event.detail.intersection.point.x;
                      cameraPosition.y = event.detail.intersection.point.y  + 0.5;
                      cameraPosition.z = event.detail.intersection.point.z  + 3;
                        */
                      // set node isSelected here
                      var nodeText = this.getAttribute('label');
                        entered = true;
                        
                        
                        });
                    
                    // Cursor Hover
                    this.el.addEventListener('mouseenter', function (event) {
                    
                      popUpPosition.x = event.detail.intersection.point.x;
                      popUpPosition.y = event.detail.intersection.point.y;
                      popUpPosition.z = event.detail.intersection.point.z;
                      
                      popUpImage.setAttribute('src', 'media/gsk-logo.jpg');
                      popUpImage.setAttribute('height', 0.25);
                      popUpImage.setAttribute('width', 0.5);
                      popUpImage.setAttribute('opacity', 0.5);
                      popUpImage.setAttribute('position', '' + (cameraPosition.x - 2) + ' ' + (cameraPosition.y) + ' ' + (cameraPosition.z - 3.199) + '');
                        
                      popUpInfoPlane.setAttribute('height', 0.25);
                      popUpInfoPlane.setAttribute('width', 1.5);
                      popUpInfoPlane.setAttribute('rotation', '0 0 0');
                      popUpInfoPlane.setAttribute('opacity', 0.5);
                      popUpInfoPlane.setAttribute('position', '' + (cameraPosition.x - 1.5) + ' ' + (cameraPosition.y) + ' ' + (cameraPosition.z - 3.2) + '');
                        
                      popUpInfo.setAttribute('value', this.getAttribute('label'));
                      popUpInfo.setAttribute('color', 'black');
                      popUpInfo.setAttribute('height', '1');
                      popUpInfo.setAttribute('width', '2');
                      popUpInfo.setAttribute('opacity', 0.5);
                      popUpInfo.setAttribute('position', '' + (cameraPosition.x - 1.5) + ' ' + (cameraPosition.y) + ' ' + (cameraPosition.z - 3.19) + '')
                        
                      //menu.object3D.lookAt(cameraPosition);    
                        
                      entered = false;
                    
                    });
                      
                    // Cursor Leave
                    this.el.addEventListener('mouseleave', function (event) {
                        
                        if(entered == false){
                          popUpImage.setAttribute('opacity', 0.0);
                          popUpInfoPlane.setAttribute('opacity', 0.0);
                          popUpInfo.setAttribute('opacity', 0.0);
                      }
                      
                    });
                      
                  }
                });
                
                loadData();
                //loadJSONGraph();
            }

          function checkKeyDown(event){
              
              myKeys.keydown[event.keyCode] = true;
              var char = String.fromCharCode(event.keyCode);
                
            }
          
            function checkKeyUp(event){
                myKeys.keydown[event.keyCode] = false;
                
                var char = String.fromCharCode(event.keyCode);
                
            }
            
            function update(){
                requestAnimationFrame(update);
                
                if(calculating == true){
                    calcForce();
                }
                
                                
                renderer.render(scene, camera3);
                mesh.geometry.attributes.position.needsUpdate = true;
                nodeMesh.geometry.attributes.position.needsUpdate = true;
                
                var acceleration = new THREE.Vector3(0,0,0);
                
                if(myKeys.keydown[myKeys.KEYBOARD.KEY_w]){
                    acceleration = calcMovement(0);
                }
                if(myKeys.keydown[myKeys.KEYBOARD.KEY_a]){
                    acceleration = calcMovement(1);
                }
                if(myKeys.keydown[myKeys.KEYBOARD.KEY_s]){
                    acceleration = calcMovement(2);
                }
                if(myKeys.keydown[myKeys.KEYBOARD.KEY_d]){
                    acceleration = calcMovement(3);
                }
                
                if(myKeys.keydown[myKeys.KEYBOARD.KEY_e]){
                    cameraPosition.y += 0.25;
                    camera.setAttribute('position', '' + cameraPosition.x + ' ' + cameraPosition.y + ' ' + cameraPosition.z + '');
                }
                if(myKeys.keydown[myKeys.KEYBOARD.KEY_q]){
                    cameraPosition.y -= 0.25;
                    camera.setAttribute('position', '' + cameraPosition.x + ' ' + cameraPosition.y + ' ' + cameraPosition.z + '');
                }
                if(myKeys.keydown[myKeys.KEYBOARD.KEY_SPACE]){
                    cameraSpeed.multiplyScalar(0.5);
                }
                
                if (myKeys.keydown[myKeys.KEYBOARD.KEY_r] && myKeys.keydown[myKeys.KEYBOARD.KEY_SHIFT]){
                    rotateStructure -= 0.5;
                    document.querySelector("#structure").setAttribute('rotation', '0 ' + rotations + ' 0');
                }
                else if(myKeys.keydown[myKeys.KEYBOARD.KEY_r]){
                    rotateStructure += 0.5;
                    document.querySelector("#structure").setAttribute('rotation', '0 ' + rotations + ' 0');
                }
                
                if(myKeys.keydown[myKeys.KEYBOARD.KEY_c]){
                    calculating = true;
                }
                if(myKeys.keydown[myKeys.KEYBOARD.KEY_x]){
                    calculating = false;
                }
                
                acceleration.multiplyScalar(0.005);
                cameraSpeed.add(acceleration);
                
                cameraPosition.add(cameraSpeed);
                
                camera.setAttribute('position', '' + cameraPosition.x + ' ' + cameraPosition.y + ' ' + cameraPosition.z + '');
                
                cameraSpeed.multiplyScalar(0.97);
                
                if(cameraSpeed.x < 0.001 && cameraSpeed.y < 0.001  && cameraSpeed.z < 0.001 && cameraSpeed.x > -0.001 && cameraSpeed.y > -0.001  && cameraSpeed.z > -0.001){
                    cameraSpeed.multiplyScalar(0);
                }

            }
            
            // Calculate camera movement
            function calcMovement(direction){
                var cameraRotation = camera.getAttribute('rotation');
                
                var theta = cameraRotation.y;
                var phi = cameraRotation.x;
                
                theta += 90;
                
                theta = theta * Math.PI / 180;
                phi = phi * Math.PI / 180;
                
                theta *= -1;
                
                var xDist = Math.cos(theta);
                var zDist = Math.sin(theta);
                var yDist = Math.sin(phi);
                
                var forward = new THREE.Vector3(xDist, yDist, zDist);
                var backward = new THREE.Vector3(-1, -1, -1);
                var right = new THREE.Vector3(0, 0, 0);
                var up = new THREE.Vector3(0, 1, 0);
                var left = new THREE.Vector3(-1, -1, -1);
                
                backward.multiplyVectors(forward, backward);
                right.crossVectors(forward, up);
                left.multiplyVectors(right, left);
                
                if(direction == 0){ // Forward / 'w'
                    forward.normalize();
                    return forward;
                }
                else if(direction == 1){ // Left / 'a'
                    left.normalize();
                    return left;
                }
                else if(direction == 2){ // Backward / 's'
                    backward.normalize();
                    return backward;
                }
                else if(direction == 3){ // Right / 'd'
                    right.normalize();
                    return right;
                }
                else{
                    var none = new THREE.Vectob3(0,0,0);
                    return none;
                }
 
            }
            
            // Main update loop
            
            // Calculate the forces acting on the nodes
            function calcForce(){
                start = new Date();
                
                
                
                 // Calculate spring force for neighbor nodes (attractive)
                for(var i = 0; i < allEdges.length; i++){
                    
                    
                    var sourceNode = allEdges[i].getAttribute('source');
                    var targetNode = allEdges[i].getAttribute('target');
                    var edgeWeight = allEdges[i].getAttribute('weight');
                    
                    var distanceMag = nodePositions[sourceNode].distanceTo(nodePositions[targetNode]);
                            
                    //distanceMag -= springEquilibrium;

                    var distanceVec = new THREE.Vector3(0, 0, 0);

                    distanceVec.subVectors(nodePositions[targetNode], nodePositions[sourceNode]);
                    
                    var addVectors = new THREE.Vector3(0,0,0);
                    
                    addVectors.addVectors(nodePositions[targetNode], nodePositions[sourceNode]);
                    
                    addVectors.divideScalar(2);
                    
                    

                    distanceVec.normalize();
                    
                    var springForce = distanceVec.multiplyScalar(springConstant * 3 * (distanceMag - 1));

                    forceOnNode[sourceNode].addVectors(forceOnNode[sourceNode], springForce);
                    
                    springForce.multiplyScalar(-1);
                    
                    forceOnNode[targetNode].addVectors(forceOnNode[targetNode], springForce);
                    
                   
                }
                

                for(var i = 0; i < allNodes.length; i++){
                    
 
                    // Calculate magnetic force for all nodes (repulsive)
                    for(var j = 0; j < allNodes.length; j++){
                        if(i != j){
                            //for(var k = 0; k < neighborList[i].length; k++){
                                
                                //if(k != neighborList[k]){
                                     var distanceMag = nodePositions[j].distanceTo(nodePositions[i]);
                            
                                    if(distanceMag < 25){
                                        var distanceVec = new THREE.Vector3(0, 0, 0);

                                        distanceVec.subVectors(nodePositions[j], nodePositions[i]);

                                        distanceVec.normalize();

                                        var magneticForce = distanceVec.multiplyScalar(-coulombConstant * ((nodeCharge * nodeCharge) / (distanceMag * distanceMag)));
                                        //var magneticForce = new THREE.Vector3(1, 1, 1);
                                        //console.dir(magneticForce);
                                        forceOnNode[i].addVectors(forceOnNode[i], magneticForce); 
                                }
                                
                           //}
                            
                            
                            
                            
                        //}   
                        
                        
                    }
                    }
                    
                }
                 
                applyForce();
            }
            
            function secondForce(){
                 for(var i = 0; i < allEdges.length; i++){
                    
                    
                    var sourceNode = allEdges[i].getAttribute('source');
                    var targetNode = allEdges[i].getAttribute('target');
                    var edgeWeight = allEdges[i].getAttribute('weight');
                    
                    var distanceMag = nodePositions[sourceNode].distanceTo(nodePositions[targetNode]);
                            
                    //distanceMag -= springEquilibrium;

                    var distanceVec = new THREE.Vector3(0, 0, 0);

                    distanceVec.subVectors(nodePositions[targetNode], nodePositions[sourceNode]);

                    distanceVec.normalize();
                    
                    var springForce = distanceVec.multiplyScalar(springConstant * (distanceMag - 1));

                    forceOnNode[sourceNode].addVectors(forceOnNode[sourceNode], springForce);
                    
                    springForce.multiplyScalar(-1);
                    
                    forceOnNode[targetNode].addVectors(forceOnNode[targetNode], springForce);
           
                }
                applyForce();
            }
            
            // Apply the calculated forces to the nodes
            function applyForce(){

                for(var i = 0; i < allNodes.length; i++){
                    
                    prevPosition[i] = nodePositions[i];
                    
                    displacement += forceOnNode[i].length();
                    
                    forceOnNode[i].normalize();
                    forceOnNode[i].divideScalar(layoutSpeed); // make this small at first and then get larger
                    nodePositions[i].addVectors(nodePositions[i],  forceOnNode[i]);
                    
                    var distanceVec = new THREE.Vector3(0,0,0);
                    
                    distanceVec.subVectors(nodePositions[i], prevPosition[i]);
                    
                    var distanceMag = forceOnNode[i].length();

                    
                }
                
                
                
                
                meanForce += displacement;
                
                var average = meanForce / meanForceIndexTracker;
                
                meanForceIndexTracker += 1;

                if(displacement > maxForce){
                    maxForce = displacement;
                    minForce = displacement;
                }
                if(displacement < minForce){
                    minForce = displacement;
                }

                percentForce = ((maxForce - average) / maxForce) * 100;
                
                
                if(percentForce > 99.9){
                    calculating = false;
                    
                }
                
                layoutSpeed = (steps * 2) / 100;

                /*
                if(percentForce > 98 && percentForce < 99){
                    layoutSpeed = 5;
                }
                else if(percentForce >= 99){
                    layoutSpeed = 10;
                }
                */
                
                /*
                else if(percentForce >= 99.5){
                    layoutSpeed = 25;
                }
                */
                
                displacement = 0;
                
                elapsed = new Date() - start;
                
                steps += 1;
                
                stepTime += elapsed;
                
                if(steps % 4 == 0){
                    updatePosition();
                    geometry.computeBoundingSphere();
                    nodeGeometry.computeBoundingSphere();
                }
                
                if(calculating == false){
                    updatePosition();
                    console.log("steps: " + steps);
                    averageStepTime = stepTime / steps;
                    console.log("averageStepTime: " + averageStepTime);
               }
               
            }
            
            
            // Update the nodes and edges positions based on the applied forces
            function updatePosition(){
                
                for(var i = 0; i < allNodes.length; i++){
                    //if(i != mostConnected){
                        //allNodes[i].setAttribute('position', '' + nodePositions[i].x + ' ' + nodePositions[i].y + ' ' + nodePositions[i].z);
                    //}
                    
                    positions[i * 3] = nodePositions[i].x;
                    positions[i * 3 + 1] = nodePositions[i].y;
                    positions[i * 3 + 2] = nodePositions[i].z;
                    
                }
                
                for(var i = 0; i < allEdges.length; i++){
                    /*
                    allEdges[i].setAttribute('line', {
                            start: '' + nodePositions[allEdges[i].getAttribute('source')].x + ' ' + nodePositions[allEdges[i].getAttribute('source')].y + ' ' + nodePositions[allEdges[i].getAttribute('source')].z + '',
                            end: '' + nodePositions[allEdges[i].getAttribute('target')].x + ' ' + nodePositions[allEdges[i].getAttribute('target')].y + ' ' + nodePositions[allEdges[i].getAttribute('target')].z + '',
                            //color: '#FFF'
                        });
                    */
                    
                    lineVertices[i * 6] =  nodePositions[allEdges[i].getAttribute('source')].x;
                    lineVertices[i * 6 + 1] =  nodePositions[allEdges[i].getAttribute('source')].y;
                    lineVertices[i * 6 + 2] =  nodePositions[allEdges[i].getAttribute('source')].z;
                    lineVertices[i * 6 + 3] =  nodePositions[allEdges[i].getAttribute('target')].x;
                    lineVertices[i * 6 + 4] =  nodePositions[allEdges[i].getAttribute('target')].y;
                    lineVertices[i * 6 + 5] =  nodePositions[allEdges[i].getAttribute('target')].z;
                        
                }

                
                
                
                
                
                
            }

            
            function updateEdgeAnimation(){
                for(var i = 0; i < allEdges.length; i++){
                    var source = allEdges[i].getAttribute('source');
                    var target = allEdges[i].getAttribute('target');
                    
                    var newSphere = document.createElement('a-entity');
                    
                    newSphere.setAttribute('geometry',{
                            primitive: 'sphere',
                            //radiusTop: 0,
                            //radiusBottom: nodeSize / 50,
                            //height: 0.25,
                            //width: 0.25,
                            //depth: 0.25
                            radius: 0.15,
                            buffer: true
                        });
                    
                    
                    /*
                    newSphere.setAttribute('material',{
                        opacity: 0.55,
                        color: 'rgb(' + (Math.floor(Math.random * 255)) + ", " + (Math.floor(Math.random * 255)) + ", " + (Math.floor(Math.random * 255)) + ")"
                    });
                    */
                    
                    
                    var nodeMoveAnimation = document.createElement('a-animation');
                      //nodeMoveAnimation.setAttribute('easing', 'ease-out');
                    
                      nodeMoveAnimation.setAttribute('attribute', 'position');
                    
                      nodeMoveAnimation.setAttribute("repeat", "indefinite");
                      nodeMoveAnimation.setAttribute('from', '' + nodePositions[source].x + ' ' + nodePositions[source].y + ' ' + nodePositions[source].z + '');
                      nodeMoveAnimation.setAttribute('to', '' + nodePositions[target].x + ' ' + nodePositions[target].y + ' ' + nodePositions[target].z + '');
                      var ranNum = Math.floor(Math.random() * 1000) + 4000;
                      nodeMoveAnimation.setAttribute('dur', ranNum);
                      newSphere.appendChild(nodeMoveAnimation);
                      document.querySelector("#structure").appendChild(newSphere);
                }
            }
            
            
        
            
            // Load data from xml file
            function loadData(){
                var xhr = new XMLHttpRequest();

                // Once XML Request has loaded
                xhr.onload = function(){
                    
                    // Store xml response in variable
                    var xml = xhr.responseXML;
                    
                    // get nodes and edges from xml
                    var nodes = xml.querySelectorAll('node');
                    //console.dir(nodes);
                    var edges = xml.querySelectorAll('edge');
                    //console.dir(nodes);
                 
                    // Loop through all nodes
                    // Get all node attributes
                    // Create sphere for node's position and size
                    // Create text for label
                    
                    
                    // Define neighborList indices as arrays
                    for(var i = 0; i < edges.length + 1; i++){
                        neighborList[i] = [];
                    }
                   
                    geometry = new THREE.BufferGeometry();
                    material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
                    
                    colors = new Float32Array( edges.length * 6 );
                    nodeColors = new Float32Array( nodes.length * 3 );
                    lineVertices = new Float32Array(edges.length * 6 );
                    
                    
                    // Loop through all edges
                    // Get all edge attributes
                    for(var i = 0; i < edges.length; i++){
                        // get current edge
                        var edge = edges[i];
                        // get current edge's id
                        var edgeID = edge.getAttribute('id');
                        // get current edge's source
                        var edgeSource = edge.getAttribute('source');
                        // get current edge's target
                        var edgeTarget = edge.getAttribute('target');
                        
                        var pearson = edge.getAttribute('Rp');
                        

                        //var sourcePosition = nodePositions[Math.floor(edgeSource)];
                        //var targetPosition = nodePositions[Math.floor(edgeTarget)];
                        
                        neighborList[Math.floor(edgeSource)].push(Math.floor(edgeTarget));
                        neighborList[Math.floor(edgeTarget)].push(Math.floor(edgeSource));
                        
                        // THREE BUFFER LINE

                        //positions[i] = 0;
                        colors[i] = '8';
                        colors[i * 6 + 1] = '8';
                        colors[i * 6 + 2] = '8';
                        colors[i * 6 + 3] = '8';
                        colors[i * 6 + 4] = '8';
                        colors[i * 6 + 5] = '8';
                        
                        
                        lineVertices[i * 6] = 1;
                        lineVertices[i * 6 + 1] = 1;
                        lineVertices[i * 6 + 2] = 1;
                        lineVertices[i * 6 + 3] = 2;
                        lineVertices[i * 6 + 4] = 2;
                        lineVertices[i * 6 + 5] = 2;
                        

                        var edgeLine = document.createElement('a-entity');
                        
                        edgeLine.setAttribute('source', Math.floor(edgeSource));
                        edgeLine.setAttribute('target', Math.floor(edgeTarget));
                        
                        
                        
                        if(pearson > 0.7){
                            edgeLine.setAttribute('line', {
                                //start: '' + sourcePosition.x + ' ' + sourcePosition.y + ' ' + sourcePosition.z + '',
                                //end: '' + targetPosition.x + ' ' + targetPosition.y + ' ' + targetPosition.z + '',
                                color: '#0F0',
                                //opacity: 0.25
                            });
                            console.log(pearson);
                        }
                        else{
                            edgeLine.setAttribute('line', {
                                //start: '' + sourcePosition.x + ' ' + sourcePosition.y + ' ' + sourcePosition.z + '',
                                //end: '' + targetPosition.x + ' ' + targetPosition.y + ' ' + targetPosition.z + '',
                                color: '#FFF',
                                opacity: 0.25
                            });
                        }
                        //console.log(allNodes[Math.floor(edgeSource)].getAttribute('size'));
                        edgeLine.setAttribute('weight', (pearson));
                        
                        edgeLine.setAttribute('cursor-listener', false);
                        edgeLine.setAttribute('class', "ignore-ray");
                        allEdges.push(edgeLine);
                        //document.querySelector('#structure').appendChild(edgeLine);
                        
                        var nodeMoveAnimation = document.createElement('a-animation');
                        
                   
                    }
                    
                    geometry.addAttribute( 'position', new THREE.BufferAttribute( lineVertices, 3 ).setDynamic( true )  );
                    geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
                    
                    geometry.computeBoundingSphere();
                    
                    material.transparent = true;
                    material.opacity = 0.5;
                    
                    mesh = new THREE.LineSegments( geometry, material );
                    
                    camera3.add( mesh );
                    
                    console.dir(edges.length);

                    var sizes = new Float32Array( nodes.length );

                    nodeGeometry = new THREE.BufferGeometry();

                    
                    positions = new Float32Array( nodes.length * 3 );
                    
                    
                    for(var i = 0; i < nodes.length; i++){
                        // get the current node
                        var node = nodes[i];
                        // get the current node's id
                        var nodeID = node.getAttribute('id');
                        // get the current node's label
                        var nodeLabel = node.getAttribute('label');

                        
                        // Save the node's position
                        //nodePositions[i] = new THREE.Vector3((nodePositionX / 100), (nodePositionY / 100), randomZ);
                        nodePositions[i] = new THREE.Vector3(Math.random(), Math.random(), Math.random());
                        startPositions[i] = new THREE.Vector3(nodePositions[i].x, nodePositions.y, nodePositions.z);

                        positions[ i * 3 + 0 ] = Math.random() * 2 - 1;
                        positions[ i * 3 + 1 ] = Math.random() * 2 - 1;
                        positions[ i * 3 + 2 ] = Math.random() * 2 - 1;
                        
                        sizes[i] = neighborList[i].length / 10 + 2;
                        
                        var color = new THREE.Color();
                       
                        

                        color.setRGB( neighborList[i].length * 0.075, 0, 0 );

                        color.toArray( nodeColors, i * 3 );

                        // create sphere for node
                        var nodeSphere = document.createElement('a-entity');
                        nodeSphere.setAttribute('geometry', {
                            primitive: 'sphere',
                            radius: ((Math.log(neighborList[i].length) + 1) / 10),
                            //radiusBottom: nodeSize / 50,
                            //height: ((Math.log(neighborList[i].length) + 1) / 5),
                            //width: ((Math.log(neighborList[i].length) + 1) / 5),
                            //depth: ((Math.log(neighborList[i].length) + 1) / 5)
                            buffer: true
                        });
                        
                        nodeSphere.setAttribute('position', {
                            x: startPositions[i].z,
                            y: startPositions[i].y,
                            z: startPositions[i].z
                        })
                        
                        nodeSphere.setAttribute('material', {
                            color: 'rgb(' + (neighborList[i].length * 5) + ',' + 0 + ',' + 0 +')',
                            //normalMap: 'media/normalMap7.jpg',
                            metalness: '0.0',
                            //fog: 'type: linear; color: #AAA'
                            //opacity: (neighborList[i].length / 100) + 0.2
                        });
                        //nodeSphere.setAttribute('size', nodeSize);
                        //nodeSphere.setAttribute('buffer', true);
                        
                        nodeSphere.setAttribute('cursor-listener', true);
                        nodeSphere.setAttribute('label', nodeLabel);
                        nodeSphere.setAttribute('nodeID', nodeID);
                        nodeSphere.setAttribute('isSelected', false);
                        nodeSphere.setAttribute('class', 'collidable')
                        allNodes.push(nodeSphere);
                        //document.querySelector('#structure').appendChild(nodeSphere);

                    }

                    
                    nodeGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).setDynamic( true ) );
                    nodeGeometry.addAttribute( 'ca', new THREE.BufferAttribute( nodeColors, 3 ) );
                    nodeGeometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );
                    
                    var texture = new THREE.TextureLoader().load( "media/ball.png" );
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    material = new THREE.ShaderMaterial( {
                        uniforms: {
                            amplitude: { value: 1.0 },
                            color:     { value: new THREE.Color( 0xffffff ) },
                            texture:   { value: texture }
                        },
                        vertexShader:   document.getElementById( 'vertexshader' ).textContent,
                        fragmentShader: document.getElementById( 'fragmentshader' ).textContent
                    });
                    //
                    nodeGeometry.computeBoundingSphere();
                    nodeMesh = new THREE.Points( nodeGeometry, material );
                    camera3.add(nodeMesh);
                    scene.add( camera3 );

                    
                    for(var i = 0; i < allNodes.length; i++){
                        forceOnNode[i] = new THREE.Vector3(0, 0, 0);
                     }
                    for(var i = 0; i < neighborList.length; i++){
                        if(neighborList[i].length > mostConnected){
                            mostConnected = i;
                        }
                    }
                    
                    update();
                    
                    
                    cursor.setAttribute('raycaster', {
                        objects: '.collidable'
                    });
                    
                }

                // store the path to the data file
                var path = "data/gephi.exported.xml";

                // open the xml request
                xhr.open('GET', path, true);
                // set request header
                xhr.setRequestHeader("If-Modified-Since", "Sat, 1 Jan 2010 00:00:00 GMT");
                // send the request
                xhr.send();

            }

            // Load init when page has loaded
            window.onload = init;
            
        }());

    </script>
    
</head>

<body>
    
    <a-scene id="scene" stats antialias="true" >

     <a-entity id="structure" position='0 0 0'>
      
      </a-entity>
        
        <a-entity id="menu" position='0 0 0' rotation="0 20 0">
      
            </a-entity>
        
        <a-camera id='camera' fov='50' near="0.5" position="0 0 50" reverse-mouse-drag='false' wasd-controls='enabled: false'>
            
            <a-entity id="cursor" cursor="fuse: true"
              raycaster="far: 100; interval: 1000"
              scale='0.02 0.02 0.02'
              position='0 0 -1.5'
              geometry="primitive: ring"
              class='ignore-ray'
              material="color: white">
              
              <a-animation begin="click" easing="ease-in" attribute="scale"
                     fill="backwards" from="0.05 0.05 0.05" to="0.02 0.02 0.02" dur="500"></a-animation>
              
            
            <a-animation begin="cursor-fusing" easing="ease-in" attribute="material.color"
                           fill="forwards" from="white" to="#00FF00" dur="1500"></a-animation>
            
            <a-animation begin="click" easing="ease-in" attribute="material.color"
                           fill="forwards" from="#00FF00" to="white" dur="500"></a-animation>
              
            </a-entity>
            
        </a-camera>

      
      <a-sky color="black" class='ignore-ray' cursor-listener='false'></a-sky>
            

      <a-plane color="tan" height="200" width="200" position="0 -100 0" rotation="-90 0 0"></a-plane>
      <a-box color="gray" height="250" width="200" depth="200" scale="-1 1 1"></a-box>
    </a-scene>
    
</body>

</html>